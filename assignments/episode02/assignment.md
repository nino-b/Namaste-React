<h1>What is NPM?</h1>


- NPM stands for Node Package Manager. 
- It is a package manager for the JavaScript programming language and is the default package manager for the JavaScript runtime environment Node.js. 
- NPM consists of a ```command line client``` (also called ```npm```) and an ```online database of public and paid-for private packages```, known as the ```npm registry```. 
   - The registry is accessed via the client, and the available packages can be browsed and searched via the npm website.

<h2>NPM is used to:</h2>

- Install and manage dependencies for Node.js applications. Dependencies are specified in a ```package.json``` file, and npm automatically installs them.
- Share packages of code with other developers around the world. Developers can publish their packages to the npm registry to be used by others.
- Run scripts and build processes. The ```package.json``` file can also specify scripts that can be run using npm, which is useful for tasks like starting a server, running tests, or compiling code.
- The npm toolset also provides version management and dependency resolution, which helps developers avoid version conflicts and manage dependencies efficiently. It's an essential tool for modern web development, especially for those working with Node.js or front-end technologies that rely on Node.js packages.





With npm, you can easily manage these packages in your Node.js projects. <h2>Here's how it generally works:</h2>

<h3>Installation:</h3> You use npm to install a package from the npm registry, a large repository of public packages. You can install packages globally (available across all projects on your machine) or locally (available only within a specific project).

<h3>package.json:</h3> This is a file in your project directory that keeps track of all the packages your project depends on. When you install a package using npm, it gets listed in this file along with its version number. This helps in managing and sharing project dependencies.

<h3>Version Management:</h3> npm handles different versions of packages to ensure compatibility and stability of your application. You can specify which version of a package your project needs, and npm will take care of installing the correct version.
      
- ^ (Caret): Updates to the latest minor version (recommended for getting new features and fixes). E.g.: If you have ^2.5.0, npm can update to any 2.x.x version greater than or equal to 2.5.0 but will not update to 3.0.0 or higher.
- ~ (Tilde): Updates to the latest patch version within the minor version specified (for getting bug fixes). E.g.: If you have ~2.5.0, npm can update to any 2.5.x version greater than or equal to 2.5.0 but will not update to 2.6.0 or higher.
- No prefix: Sticks to the exact version specified, with no updates applied automatically (for ensuring absolute consistency).

<h3>Dependency Resolution:</h3> Often, packages depend on other packages. npm automatically resolves these dependencies, ensuring that all the necessary packages are installed for your project to work.





<h1>What is Parcel / Webpack? Why do we need it?</h1>

Parcel and Webpack are powerful tools used in web development to bundle assets, scripts, and dependencies into a format that's optimized for serving to a browser. They are module bundlers that take modules with dependencies and generate static assets representing those modules. While they share some similarities in purpose, they differ in their approach and default configurations. 

<h2>Why Do We Need Them?</h2>
The complexity of web applications has grown significantly, with applications often depending on numerous libraries, frameworks, and other assets. Managing these dependencies manually in a way that's optimized for both development and production can be challenging. Module bundlers like Parcel and Webpack solve these problems by:

<h3>Optimizing Performance:</h3> They bundle and minify JavaScript, CSS, and other assets, reducing the number of requests needed to load a web page and improving load times.

<h3>Simplifying Development:</h3> By bundling assets together and enabling features like hot module replacement, they streamline the development process, making it faster and more efficient.

<h3>Handling Dependencies:</h3> They manage and bundle dependencies from NPM or other sources, ensuring that the code you write works seamlessly with the libraries it depends on.

<h3>Transpiling Modern JavaScript:</h3> They allow developers to write modern JavaScript (ES6+) that is transpiled to ES5 to ensure compatibility with older browsers.

<h3>Enabling Modular Code:</h3> Promote modular programming by allowing developers to write modular code that is bundled together in a coherent and optimized way for production.





<h1>What is .parcel-cache?</h1>

.parcel-cache is a directory generated by Parcel. This directory is used by Parcel to store cache data from your projects to speed up the build process. The cache includes compiled assets, transformed modules, and other files that Parcel has processed. By caching these elements, Parcel can avoid redoing work that has already been completed in previous builds, significantly reducing build times, especially during development when files are frequently changed and the project is rebuilt multiple times.

<h3>Version Control:</h3> It's recommended to exclude the .parcel-cache directory from version control (e.g., by adding it to your .gitignore file) because it can grow quite large, and its contents are specific to each developer's environment. Including it in version control would unnecessarily bloat the repository and could lead to conflicts between different environments.


<h3>When to Clear .parcel-cache:</h3>

Clearing the cache is a useful troubleshooting step if you're experiencing odd behavior with your builds that you cannot attribute to your source code.
- Outdated data being served in your application.
- Build failures after updating dependencies or making significant changes to your project's configuration.
- Incorrect behavior that cannot be reproduced by other team members or in other environments.





<h1>What is npx?</h1>

The term "npx" refers to a package runner tool that comes with Node.js. When you install Node.js, npx is also installed automatically as part of the Node Package Manager (npm). It is used to execute Node packages without having to install them globally. This is particularly useful for running packages, testing them, or executing commands from packages not currently installed on your system.





<h1>What is the difference between dependencies anv devDependencies?</h1>

- dependencies: Lists the packages your project depends on to run. npm automatically installs these packages when someone installs your project.
- devDependencies: Lists the packages needed for development and testing, but not for running the project in production.





<h1>What is Tree Shaking?</h1>

Tree shaking is a term commonly used in the context of JavaScript and web development to describe a process of optimization that aims to reduce the size of a project's final bundle. It works by eliminating code that isn't actually used (referred to as "dead code") from the final output. This process is particularly beneficial for applications that use large libraries or frameworks, as it ensures that only the code that is actually needed by the application is included in the build, leading to smaller bundle sizes and faster loading times.





<h1>What is Hot Module Replacement?</h1>

Hot Module Replacement (HMR) is a feature provided by various development servers and build tools, such as Webpack, which allows for real-time updating of modules in a browser without needing a full refresh. This means that when you make changes to your code—particularly in JavaScript, CSS, or even certain framework components—the updates can be applied live as you develop, without losing the current state of the application. HMR enhances the development experience by making it faster and more efficient.





<h1>List down 'superpowers' of parcel and describe them.</h1>

<h2>Dev Build</h2>
Parcel automatically optimizes the build process for development by prioritizing fast build times and efficient updates, ensuring developers can see changes quickly without waiting for long build processes.
<h2>Local Server</h2>
Provides a built-in development server that can be started with minimal configuration, making it easy to develop and test web applications locally.
<h2>HMR (Hot Module Replacement)</h2>
Supports HMR out of the box, allowing developers to see updates in the browser without needing a full page refresh, preserving the state of the application during development.
<h2>File Watching Algorithm</h2>
Utilizes a file watching algorithm, written in C++, to efficiently detect changes in the project files. This contributes to quicker rebuilds by only processing files that have changed.
<h2>Caching</h2>
Caches compiled assets and modules to speed up subsequent builds. This means that once a file is processed, it won't need to be re-processed in future builds unless it changes, leading to significantly faster build times.
<h2>Image Optimization</h2>
Automatically optimizes images included in your project, reducing their file size without losing quality, which can improve load times for your web application.
<h2>Minification</h2>
Minifies JavaScript, CSS, and HTML files in production builds, removing unnecessary characters from code without changing its functionality, resulting in smaller bundle sizes.
<h2>Bundling</h2>
Combines and links together all the modules and assets your application depends on into a smaller number of files, optimizing load times and simplifying deployment.
<h2>Compression</h2>
Supports compressing bundled assets using algorithms like Gzip or Brotli, further reducing the size of files sent to the client.
<h2>Consistent Hashing</h2>
Uses consistent hashing for output filenames, ensuring that file names only change when the content of the files changes, which improves browser caching.
<h2>Code Splitting</h2>
Allows you to split your code into separate bundles that can be loaded on demand, improving initial load time by only loading what's necessary upfront.
<h2>Differential Bundling</h2>
Supports creating different bundles for different browsers, allowing you to serve modern, more efficient code to newer browsers while still supporting older browsers with fallback bundles.
<h2>Diagnostic</h2>
Provides detailed diagnostic messages and error reports to help identify and fix issues quickly during development.
<h2>Error Handling</h2>
Robust error handling mechanisms improve the development experience by clearly indicating issues and potential fixes.
<h2>HTTPS</h2>
The development server can serve files over HTTPS, making it easier to test features that require a secure context.
<h2>Tree Shaking</h2>
Eliminates unused code from your bundles, ensuring that only the code that is actually used is included in the final build, reducing the size and improving the performance of your application.
<h2>Different dev and production bundles</h2>
Automatically differentiates between development and production builds, optimizing the latter for performance by applying additional optimizations like minification and compression.





<h1>What is the difference between package.json and package-lock.json?</h1>

<h2>package.json</h2>

<h3>Purpose:</h3> This file holds various metadata relevant to the project. It's used to give information to npm that allows it to identify the project as well as handle the project's dependencies. It can include the project's name, version, scripts, dependencies, devDependencies, and more.
<h3>Dependencies:</h3> In package.json, the dependencies are listed with version ranges. This means you're not specifying exact versions of each package, but rather a range of versions that are acceptable for your project. When you run npm install, npm will install the latest versions of the packages that satisfy these version ranges.
<h3>Human-Edited:</h3> This file is often manually edited by developers when they want to add or update dependencies, scripts, and other project metadata.

<h2>package-lock.json</h2>

<h3>Purpose:</h3> The package-lock.json file is automatically generated when you run npm install. Its main role is to lock the versions of your project's dependencies (and the dependencies of those dependencies, and so on) to ensure that every install results in the exact same file structure in the node_modules directory, regardless of when or where you install the packages.
<h3>Dependencies:</h3> Unlike package.json, package-lock.json contains exact versions of each package that was installed, including the dependencies of these packages. This ensures that every installation, across different machines and environments, is identical.
<h3>Automatically Generated and Updated:</h3> You generally don't manually edit this file. It's automatically updated by npm whenever the node_modules tree changes, for example, when you install, update, or remove packages.





<h1>Why should we not modify package-lock.json?</h1>

The package-lock.json file is an automatically generated file, created by npm (Node Package Manager), that precisely describes the exact tree of installed node modules (and their dependencies) in your project. It serves several important purposes and should not be manually edited for several reasons:

<h2>Ensures Consistent Installations</h2>

The primary purpose of package-lock.json is to record the exact versions of every package that was installed, ensuring that all installations of the project on any machine (development, staging, production) are consistent. This consistency is crucial for eliminating "works on my machine" problems by making sure everyone is using the same package versions.

<h2>Dependency Resolution</h2>

When you install a package, npm calculates dependencies and installs the latest versions that satisfy the version ranges specified in package.json. The package-lock.json file then locks in those versions by recording the exact version installed. This detailed record prevents npm from repeatedly resolving package versions on every install, speeding up the installation process.

<h2>Integrity Verification</h2>

package-lock.json includes ```integrity hashes``` for each installed package. These hashes provide a mechanism to verify that the contents of the node modules have not been altered or corrupted since they were installed. Integrity hashes only change when code changes. Manually editing the lock file could lead to discrepancies between the expected package versions and integrity hashes, potentially leading to installation errors or, worse, security risks.

<h2>Facilitates Code Review and Collaboration</h2>

By committing package-lock.json to version control, teams ensure that any changes to dependencies (whether updates, additions, or removals) are explicitly tracked and visible in code reviews. This visibility helps teams understand changes in their environment and can aid in diagnosing issues related to dependency updates.

<h2>When Changes to package-lock.json Are Appropriate</h2>

Changes to package-lock.json should occur as a result of package installation, upgrade, or removal commands via npm, such as npm install, npm update, or npm install ```<package>@<version>```. These commands automatically adjust package-lock.json to reflect the changes in the dependency tree.


<h2>Best Practices</h2>

<h3>Commit package-lock.json to Version Control:</h3> This is recommended to ensure that all team members and deployment environments use the exact same set of dependencies.

<h3>Do Not Manually Edit:</h3> Avoid manually editing this file to prevent inconsistencies and potential conflicts in your project's dependency tree.

<h3>Regularly Update Dependencies:</h3> Use commands like npm update to keep your dependencies up-to-date. This will also update package-lock.json appropriately.





<h1>What is node_modules? Is it a good idea to push it on git?</h1>

<h3>Dependency Storage:</h3> The node_modules folder stores the packages that your project depends on to run. These dependencies are defined in your project's package.json file under dependencies and devDependencies.

<h3>Hierarchical Structure:</h3> If the packages you install have their own dependencies, npm installs these within the node_modules directory of the respective package, creating a nested structure. This is how npm manages and resolves dependencies' versions for each package individually.

<h3>Size and Depth:</h3> The node_modules directory can become quite large and deeply nested, especially for large projects with many dependencies. This can sometimes lead to challenges with file system limitations on certain operating systems.

<h3>Not Version Controlled:</h3> Typically, the node_modules directory is not included in version control (e.g., Git). Instead, the package.json and package-lock.json files are used to manage and share dependency information, allowing anyone who checks out the project to install the exact same dependencies by running npm install.

<h3>Recreation:</h3> If the node_modules directory is deleted or if you clone a project without one, running npm install will recreate the node_modules directory based on the current state of package.json and package-lock.json, installing all necessary packages as specified. This is why it is not necessary to push node_modules on git.





<h1>What is the dist folder?</h1>

The dist folder, short for "distribution," is a common convention in software development. It serves as the output directory where processed, optimized, and often minified versions of the project's source code are placed, ready for deployment or distribution. 

<h2>Purpose</h2>

<h3>Optimization for Production:</h3> The dist folder contains the production-ready version of a project. This includes HTML, CSS, JavaScript, images, fonts, and any other assets that have been optimized for performance. Optimization can involve minification (removing unnecessary characters from code without changing its functionality), bundling (combining multiple files into a single file), and transpilation (converting modern JavaScript or other languages to a form compatible with older browsers).

<h3>Separation from Source Code:</h3> Keeping the production-ready files in a separate dist folder distinguishes them from the development source files, which may include unminified code, source maps, and various assets that are not directly served to users. This separation helps in maintaining a clean and organized project structure.






<h1>What is browserslist?</h1>

- It is a property in package.json file that efines the target browsers for compatibility if you're working on a frontend project.
- It takes an array of browsers as an argument ( ["last 2 Chrome version", "last 2 Firefox version"]) / "browserslist": ["last 2 version"]. This means that our code will definitely work in those versions of browsers and it might or might not work in rest of the browsers (so, it does not mean that it won't work in rest of the browsers).
- It informs various frontend tools and compilers (like Babel, Autoprefixer, ESLint, etc.) about which browsers (and their versions) they should target for compatibility.
- To check how many users have those versions of browsers: https://browserslist.dev/?q=bGFzdCAyIHZlcnNpb25z






<h1>^ caret and ~ tilda.</h1>
^ caret and ~ tilda are used to specify version ranges in package management files, such as npm for Node.js projects or composer for PHP.

- The caret ^ symbol before a version number means npm can install this version or any minor or patch release that does not change the leftmost non-zero digit. For example:
If you have ^2.5.0, npm can update to any 2.x.x version greater than or equal to 2.5.0 but will not update to 3.0.0 or higher. This allows for receiving bug fixes and new features that should not break existing functionality.
It is considered safe for adding new features without breaking existing functionality (following semantic versioning).

- The tilde ~ symbol allows updates to patch releases within a minor version. This is more restrictive than the caret. For example:
If you have ~2.5.0, npm can update to any 2.5.x version greater than or equal to 2.5.0 but will not update to 2.6.0 or higher. This is useful for receiving bug fixes but not new features that might introduce new bugs or require changes in your code.
It is more conservative, preferring to minimize the risk of introducing changes that could potentially break your application.

- When a version number is specified without a ^ or ~ prefix, npm treats this as an instruction to install that exact version only. For example:
Specifying 2.5.0 means npm will always install version 2.5.0 of the package, and it will not update the package automatically in any case. This is the most restrictive approach, ensuring absolute predictability at the cost of missing out on updates that could include important fixes or features.






<h1>Script types in html.</h1>

The ```<script>``` tag is used to define a client-side script, such as JavaScript. There are different types of scripts and ways to include them in HTML, based on how they are sourced and how they are executed. Here's an overview:

- <h3>Inline Script</h3>
An inline script is code written directly within an HTML document inside ```<script>``` tags. It is executed when the browser parses the HTML document.

```html
<script>
  // JavaScript code goes here
  alert("Hello, World!");
</script>
```
- <h3>External Script</h3>
An external script is a JavaScript file linked to the HTML document with the src attribute of the ```<script>``` tag. This approach is beneficial for reusability and separation of concerns.

```html
<script src="path/to/external/script.js"></script>
```
- <h3>Module Script</h3>
With the advent of ES6 (ECMAScript 2015), JavaScript modules allow you to use the import and export statements to share code between different JavaScript files. To use modules in an HTML document, set the type attribute of the ```<script>``` tag to "module".

```html
<script type="module" src="path/to/module/script.js"></script>
```
- <h3>Deferred Script</h3>
The defer attribute in the ```<script>``` tag tells the browser to execute the script file after the HTML document has been parsed. This does not block the parsing of the document. It's useful for scripts that don't need to be run immediately and should be used only on external scripts.

```html
<script src="path/to/script.js" defer></script>
```
- <h3>Asynchronous Script</h3>
The async attribute is used to run scripts asynchronously as soon as they are available, without waiting for the HTML document to be fully parsed. This is also applicable only to external scripts and is useful for scripts that do not depend on other scripts and do not modify the DOM.

```html
<script src="path/to/script.js" async></script>
```

- <h3>NoScript</h3>
The ```<noscript>``` tag is used to define an alternative content for users whose browsers do not support JavaScript or have it disabled. It's not a type of script but is related to scripting in HTML.
```html
<noscript>
  JavaScript is not enabled in your browser.
</noscript>
```